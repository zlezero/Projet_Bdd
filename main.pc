#define WINDOWS

#include <sqlca.h>
#include <stdio.h>
#include <string.h>
#ifdef WINDOWS
#include <windows.h>
#endif
#include <ctype.h>
#include <stdlib.h>

//Fonctions de menu
void Connexion();
void Menu_Principal();
int afficherGroupe(int idGroupe, int page);
void afficherMessage(int idMessage, int idGroupe);
void ecrireMessage(int idGroupe, int msgPere);
void Menu_Recherche();
int Resultats_Recherche(int type, char *recherche, int page);
void Menu_Top20();

//Fonctions utlitaires
void viderBuffer();
void Wait_For_Enter();
int estModerateur(char *account, int idGroupe);
int isNumber(char* str);
void clearScreen();
#ifdef LINUX
char* strupr(char* s);
#endif

EXEC SQL BEGIN DECLARE SECTION;
	varchar login[30];
	varchar pwd[30];
	char* username;
EXEC SQL END DECLARE SECTION;

void sql_error(msg)
char *msg;
{
    char err_msg[128];
    int buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    printf("\n%s\n", msg);
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &buf_len, &msg_len);
    printf("%.*s\n", msg_len, err_msg);
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}

int main(int argc, char* argv[])
{
	#ifdef WINDOWS
	SetConsoleOutputCP(65001); //Mettre en UTF-8 la console
	#endif
	Connexion(); //On lance le formulaire de connexion
	return 0;
}

void Connexion()
{
    int isCorrect = 0;
	int autoconnect = 1;
	
	while (1)
	{
		while (!isCorrect) //Tant que l'utlisateur n'est pas connecté
		{
			#ifdef WINDOWS
			system("color 2B");
			#endif
			
			clearScreen();
			
			#ifdef WINDOWS
			SetConsoleTitle("Ultra Forum Discutor - Connexion");
			#endif
			
			if (!autoconnect || sqlca.sqlcode != 0) //Si l'autoconnexion n'a pas marchée
			{
				printf("=== Ultra Forum Discutor ===\n");
				
				if (sqlca.sqlcode != 0) //Si il y a eu une erreur à la connexion précédente
					printf("\nUne erreur est survenue lors de la connexion veuillez réessayer !\n");
				
				printf("\nEntrez votre login : ");
				scanf("%20s", login.arr);
				printf("Entrez votre mot de passe : ");
				scanf("%20s", pwd.arr);
			}
			else //Si on essaye de s'autoconnecter
			{
				#ifdef WINDOWS
				strcpy(login.arr, "thomas@localhost");
				strcpy(pwd.arr, "mdp");
				#endif
				
				#ifdef LINUX
				strcpy(login.arr, "tvathonn@info");
				strcpy(pwd.arr, "azerty");
				#endif
			}

			login.len = strlen(login.arr);
			pwd.len = strlen(pwd.arr);
				
			EXEC SQL CONNECT :login IDENTIFIED BY :pwd; //On lance la connexion
		
			if (sqlca.sqlcode == 0) //Si il n'y a pas eu d'erreur
			{
				if (strchr(login.arr, '@') != NULL) //Si il existe un @ dans l'identifiant
				{
					username = malloc(strlen(login.arr)); 
					username = strtok(login.arr, "@"); //On prend la première partie de l'identifiant
					username = strupr(username);
				}
				else
					username = strupr(login.arr);

				isCorrect = 1; //On dit que c'est correct pour sortir de la boucle
			}
			
		}

		Menu_Principal();
		isCorrect = 0; //Pour reboucler si l'utilisateur veut changer de compte et réafficher le formulaire
		autoconnect = 0;
	}

}

EXEC SQL BEGIN DECLARE SECTION;
	char nomGroupe[30];
	int idGroupe;
	short idest_NomGroupe;
	short idest_idGroupe;
EXEC SQL END DECLARE SECTION;

void Menu_Principal()
{
    int nbrGroupes = 0;
	char choix[10];
	
    while (1)
    {
    	#ifdef WINDOWS
		SetConsoleTitle("Ultra Forum Discutor - Menu Principal");
        #endif
        clearScreen();
		
		nbrGroupes = 0;
		
		EXEC SQL WHENEVER SQLERROR DO sql_error("ORACLE error--"); //On gère les erreurs
		
        printf("=== MENU PRINCIPAL ===\n\n");

        //Afficher la liste des groupes
		
		EXEC SQL DECLARE afficheGroupes CURSOR FOR SELECT Idgroupe, Nomgroupe FROM Forum_Groupe; //On déclare le curseur
		EXEC SQL OPEN afficheGroupes; //On ouvre le curseur
		
		EXEC SQL FETCH afficheGroupes INTO :idGroupe:idest_idGroupe, :nomGroupe:idest_NomGroupe;
		
		printf("Liste des groupes :\n");
		
		while ((sqlca.sqlcode >= 0) && (sqlca.sqlcode != 1403)) //Tant que le curseur n'est pas vide !
		{
			if (idest_idGroupe != -1 && idest_NomGroupe != -1) //Si il ne s'agit pas d'une case vide
			{
				printf("\t%d - %s\n", idGroupe, nomGroupe); //On affiche le groupe
				EXEC SQL FETCH afficheGroupes INTO :idGroupe:idest_idGroupe, :nomGroupe:idest_NomGroupe;
				nbrGroupes += 1;
			}
		}
		
		EXEC SQL CLOSE afficheGroupes;
		
		//On affiche le menu d'actions
		
        printf("\nActions : \n");
        printf("\t- Entrez le chiffre associé au groupe pour y accéder\n");
        printf("\t- R : Rechercher un message\n");
        printf("\t- T : Afficher le top 20\n");
        printf("\t- Q : Se déconnecter\n");
				
		printf("\nEntrez votre choix : ");		
		scanf("%2s", choix);
		
		if (!strcmp(choix, "r") || !strcmp(choix, "R")) //Si l'on recherche un message
		{
			Menu_Recherche();
		}
		else if (!strcmp(choix, "t") || !strcmp(choix, "T")) //Si l'on veut afficher le top 20
		{
			Menu_Top20();
		}
		else if (!strcmp(choix, "q") || !strcmp(choix, "Q")) //Si on veut se deconnecter
		{
			EXEC SQL COMMIT WORK RELEASE;
			return;
		}
		else if (isdigit(choix[0]) || (isdigit(choix[0]) && strlen(choix) == 2 && isdigit(choix[1]))) //Si on entre un nombre
		{
			int choixInt = atoi(choix);
			
			if (choixInt >= 0 && choixInt < nbrGroupes)
			{
				afficherGroupe(choixInt, 0);
			}
			
		}

    }

}

void Menu_Top20()
{

	while (1)
	{
		#ifdef WINDOWS
		SetConsoleTitle("Ultra Forum Discutor - Top 20");
		#endif
		clearScreen();
		
		printf("=== TOP 20 DES MESSAGES LES PLUS LUS ===\n");
		
		return;
		
	}
}

void Menu_Recherche()
{
	char choix[2];
	
	while (1)
	{
		#ifdef WINDOWS
		SetConsoleTitle("Ultra Forum Discutor - Recherche");
		#endif
		clearScreen();
		
		printf("=== RECHERCHER UN MESSAGE ===\n");
		printf("\t1 - Rechercher par auteur\n");
		printf("\t2 - Rechercher par titre\n");
		printf("\t3 - Rechercher par texte\n");
		printf("\t4 - Rechercher par date\n");
		printf("\t5 - Retourner au menu principal\n");
		
		printf("\nEntrez votre choix : ");
		scanf("%1s", choix);
		
		if (!strcmp(choix, "1"))
		{
			viderBuffer();
			
			char auteur[11];
			clearScreen();
			
			printf("=== RECHERCHE PAR AUTEUR ===\n\n");
			
			printf("Entrez l'auteur : ");
			fgets(auteur, 10, stdin);
			
			if (Resultats_Recherche(0, strupr(auteur), 0) == 2)
				return;
			
		}
		else if(!strcmp(choix, "2"))
		{
			viderBuffer();
			
			char titreRech[30];
			clearScreen();
			
			printf("=== RECHERCHE PAR TITRE ===\n\n");
			printf("Entrez le titre : ");
			fgets(titreRech, 29, stdin);
			
			if (Resultats_Recherche(1, titreRech, 0))
				return;
		}
		else if (!strcmp(choix, "3"))
		{
			viderBuffer();
			
			char texteRech[100];
			clearScreen();
			
			printf("=== RECHERCHE PAR TEXTE ===\n\n");
			printf("Entrez le texte : ");
			fgets(texteRech, 99, stdin);
			
			if (Resultats_Recherche(2, texteRech, 0))
				return;
		}
		else if (!strcmp(choix, "4"))
		{
			int jour = 0, mois = 0, annee = 0;
			viderBuffer();
			
			char dateRech[100];
			clearScreen();
			
			printf("=== RECHERCHE PAR DATE ===\n\n");
			printf("Entrez la date (JJ/MM/YYYY) : ");
			sscanf(dateRech, "%2d %2d %4d", jour, mois, annee);
			printf("%d/%d/%d\n", jour, mois, annee);
			Wait_For_Enter();
			if (Resultats_Recherche(3, dateRech, 0))
				return;
		}
		else if (!strcmp(choix, "5"))
			return;
		
		viderBuffer();
		
	}
}
EXEC SQL BEGIN DECLARE SECTION;

	int pageNbrMax;
	int pageNbrMin;
	
	char rechercheString[500];
	
	int IdMessage;
	char Titre[30];
	int IdGroupe;
	
	short idest_Titre;
	short idest_idMessage;
	short idest_IdGroupe;
	
EXEC SQL END DECLARE SECTION;

int Resultats_Recherche(int type, char *recherche, int page)
{	
	
	strcpy(rechercheString, recherche);
	
	int nbrMessages = 0;
	char choix[10];
	int *idMessageTab = malloc(sizeof(int)*21);
	int autrePage = 0;
	
	while (1)
	{
		nbrMessages = 0;
		pageNbrMax = (20 * (page + 1)) + 1;
		pageNbrMin = page * 20;
		
		clearScreen();
		printf("=== RESULTATS DE LA RECHERCHE - PAGE %d ===\n", page);
		printf("Liste des messages :\n");
		
		rechercheString[strcspn(rechercheString, "\r\n")] = 0;
	
		if (!type) //Si type = 0 / On cherche par auteur	
		{
			EXEC SQL DECLARE afficheMessagesRechercheAuteur CURSOR FOR SELECT * FROM ( SELECT tmp.*, rownum rn FROM ( SELECT IdMessage, IdGroupe, Titre FROM Forum_Message Where Auteur LIKE '%' || :rechercheString || '%' ORDER BY DATEMSG) tmp WHERE rownum <= :pageNbrMax) WHERE rn > :pageNbrMin;		
			EXEC SQL OPEN afficheMessagesRechercheAuteur;		
			EXEC SQL FETCH afficheMessagesRechercheAuteur INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;
		}
		else if (type == 1) //Si type = 1 / On cherche par titre 
		{
			EXEC SQL DECLARE afficheMessagesRechercheTitre CURSOR FOR SELECT * FROM ( SELECT tmp.*, rownum rn FROM ( SELECT IdMessage, IdGroupe, Titre FROM Forum_Message Where Titre LIKE '%' || :rechercheString || '%' ORDER BY DATEMSG) tmp WHERE rownum <= :pageNbrMax) WHERE rn > :pageNbrMin;		
			EXEC SQL OPEN afficheMessagesRechercheTitre;
			EXEC SQL FETCH afficheMessagesRechercheTitre INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;
		}
		else if (type == 2) //Si type = 2 / On cherche par texte
		{
			EXEC SQL DECLARE afficheMessagesRechercheTexte CURSOR FOR SELECT * FROM ( SELECT tmp.*, rownum rn FROM ( SELECT IdMessage, IdGroupe, Titre FROM Forum_Message Where Texte LIKE '%' || :rechercheString || '%' ORDER BY DATEMSG) tmp WHERE rownum <= :pageNbrMax) WHERE rn > :pageNbrMin;		
			EXEC SQL OPEN afficheMessagesRechercheTexte;		
			EXEC SQL FETCH afficheMessagesRechercheTexte INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;
		}
		else if (type == 3) //Si type = 3 / On cherche par date
		{
			EXEC SQL DECLARE afficheMessagesRechercheDate CURSOR FOR SELECT * FROM ( SELECT tmp.*, rownum rn FROM ( SELECT IdMessage, IdGroupe, Titre FROM Forum_Message Where Auteur = :rechercheString ORDER BY DATEMSG) tmp WHERE rownum <= :pageNbrMax) WHERE rn > :pageNbrMin;		
			EXEC SQL OPEN afficheMessagesRechercheDate;		
			EXEC SQL FETCH afficheMessagesRechercheDate INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;		
		}
			
		while ((sqlca.sqlcode >= 0) && (sqlca.sqlcode != 1403)) //Tant que le curseur n'est pas vide !
		{
			if (idest_Titre != -1 && idest_idMessage != -1) //Si il ne s'agit pas d'une case vide
			{
				if (nbrMessages < 20) //On affiche les 20 premiers messages
				{
					Titre[strcspn(Titre, "\r\n")] = 0;
					printf("\t%d - %s\n", nbrMessages, Titre); //On affiche le groupe
					idMessageTab[nbrMessages] = IdMessage;
					nbrMessages += 1;
				}
				else
					autrePage = 1;
				
				if (!type)
					EXEC SQL FETCH afficheMessagesRechercheAuteur INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;
				else if (type == 1)
					EXEC SQL FETCH afficheMessagesRechercheTitre INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;
				else if (type == 2)
					EXEC SQL FETCH afficheMessagesRechercheTexte INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;
				else if (type == 3)
					EXEC SQL FETCH afficheMessagesRechercheDate INTO IdMessage:idest_idMessage, IdGroupe:idest_IdGroupe, Titre:idest_Titre;		
			}
		}
		
		if (!type)
			EXEC SQL CLOSE afficheMessagesRechercheAuteur;
		else if (type == 1)
			EXEC SQL CLOSE afficheMessagesRechercheTitre;
		else if (type == 1)
			EXEC SQL CLOSE afficheMessagesRechercheTexte;
		else if (type == 1)
			EXEC SQL CLOSE afficheMessagesRechercheDate;
		
		printf("\nActions : \n");
		printf("\t- Entrez le chiffre associé au message pour y accéder\n");
		
		if (autrePage) //Si une autre page est disponible
			printf("\t- N : Passer à la page suivante\n");
		
		if (page > 0) //Si on n'est pas dans la page 1
			printf("\t- P : Retourner à la page précédente\n");
		
		printf("\t- R : Retourner au menu de recherche\n");
		printf("\t- M : Retourner au menu principal\n");
		
		
		printf("\nEntrez votre choix : ");
		scanf("%2s", choix);
		
		if (isNumber(choix))
		{
			int choixInt = atoi(choix);
			
			if (choixInt >= 0 && choixInt < nbrMessages)
			{
				afficherMessage(idMessageTab[choixInt], idGroupe);
			}
		}
		else if (!strcmp(choix, "r") || !strcmp(choix, "R"))
			return 1;
		else if (!strcmp(choix, "m") || !strcmp(choix, "M"))
			return 2;
		else if (autrePage && (!strcmp(choix, "n") || !strcmp(choix, "N")))
		{
			int resultReturn = Resultats_Recherche(type, recherche, page + 1);
			
			if (resultReturn)
				return resultReturn;
			
		}
		else if (page > 0 && (!strcmp(choix, "p") || !strcmp(choix, "P")))
			return 0;
		
	}
}

EXEC SQL BEGIN DECLARE SECTION;
	char titre[30];
	int idMessage;
	short idest_titre;
	short idest_idMessage;
	int pageNbrMax;
	int pageNbrMin;
EXEC SQL END DECLARE SECTION;

int afficherGroupe(int idGroupe, int page)
{
	const int nbrMessageAffiche = 20;
	char choixGrp[10];
	int *idMessageTab = malloc(sizeof(int)*nbrMessageAffiche);
	int nbrMessages = 0, autrePage = 0;
	
	while (1)
	{
		pageNbrMax = (nbrMessageAffiche * (page + 1)) + 1;
		pageNbrMin = page * nbrMessageAffiche;
	
		clearScreen();
		#ifdef WINDOWS
		SetConsoleTitle("Ultra Forum Discutor - Messages");
		#endif
		//printf("Nbr max : %d / Nbr min : %d\n", pageNbrMax, pageNbrMin);
		nbrMessages = 0;
		autrePage = 0;
		
		printf("=== LISTE DES MESSAGES - PAGE %d ===\n", page + 1);
		
		EXEC SQL DECLARE afficheMessages CURSOR FOR SELECT * FROM ( SELECT tmp.*, rownum rn FROM ( SELECT IdMessage, Titre FROM Forum_Message Where idGroupe = :idGroupe AND MsgPere IS NULL ORDER BY DATEMSG) tmp WHERE rownum <= :pageNbrMax) WHERE rn > :pageNbrMin; //On déclare le curseur
		
		EXEC SQL OPEN afficheMessages;
		
		EXEC SQL FETCH afficheMessages INTO :idMessage:idest_idMessage, :titre:idest_titre;
		
		printf("\nListe des messages :\n");
		
		while ((sqlca.sqlcode >= 0) && (sqlca.sqlcode != 1403)) //Tant que le curseur n'est pas vide !
		{
			if (idest_idMessage != -1 && idest_titre != -1) //Si il ne s'agit pas d'une case vide
			{
				if (nbrMessages < nbrMessageAffiche) //On affiche les 20 premiers messages
				{
					titre[strcspn(titre, "\r\n")] = 0; //On retire les sauts de ligne du message si il y en a
					printf("\t%d - %s\n", nbrMessages, titre); //On affiche le message			
					idMessageTab[nbrMessages] = idMessage;
					nbrMessages += 1;
				}
				else //Si il y en a un en plus on dit qu'une autre page est disponible
					autrePage = 1;
				
				EXEC SQL FETCH afficheMessages INTO :idMessage:idest_idMessage, :titre:idest_titre;
			}
		}
		
		EXEC SQL CLOSE afficheMessages;
		
		if (nbrMessages == 0) //Si on viens de supprimer le dernier message de la page on retourne à la précédente
			return 0;
		
		printf("\nActions : \n");
		printf("\t- Entrez le chiffre associé au message pour y accéder\n");
		printf("\t- E : Ecrire un nouveau message\n");
		
		if (autrePage) //Si une autre page est disponible
			printf("\t- N : Passer à la page suivante\n");
		
		if (page > 0) //Si on n'est pas dans la page 1
			printf("\t- P : Retourner à la page précédente\n");
		
		printf("\t- M : Retourner au menu principal\n");

		printf("\nEntrez votre choix : ");	
		scanf("%2s", choixGrp);

		if (isdigit(choixGrp[0]) || (isdigit(choixGrp[0]) && strlen(choixGrp) == 2 && isdigit(choixGrp[1]))) //Si l'on a choisi un message
		{
			int choixInt = atoi(choixGrp);
			
			if (choixInt >= 0 && choixInt < nbrMessages)
				afficherMessage(idMessageTab[choixInt], idGroupe);
			
		}
		else  if (autrePage && (!strcmp(choixGrp, "n") || !strcmp(choixGrp, "N"))) //Si l'on veut aller à la page suivante
		{
			if (afficherGroupe(idGroupe, page + 1))
				return 1;
		}
		else if (page > 0 && (!strcmp(choixGrp, "p") || !strcmp(choixGrp, "P"))) //Si l'on veut retourner à la page précédente
			return 0;
		else if (!strcmp(choixGrp, "m") || !strcmp(choixGrp, "M")) //Si l'on veut retourner au menu principal
			return 1;
		else if (!strcmp(choixGrp, "e") || !strcmp(choixGrp, "E")) //Si l'on veut écrire un message
			ecrireMessage(idGroupe, -1);
		
	}
}

EXEC SQL BEGIN DECLARE SECTION;
	int idMax;
	char texteMsg[500];
	int MsgPere = -1;
EXEC SQL END DECLARE SECTION;

void ecrireMessage(int idGroupe, int msgPere)
{
	
	char titre[50];
	int erreur = 0;
	MsgPere = msgPere;

	while (1)
	{
		#ifdef WINDOWS
		if (msgPere != -1)
			SetConsoleTitle("Ultra Forum Discutor - Repondre a un message");
		else
			SetConsoleTitle("Ultra Forum Discutor - Ecrire un message");
		#endif
		
		viderBuffer();
		
		clearScreen();
		
		if (msgPere != -1)
			printf("=== REPONDRE A UN MESSAGE ===\n\n");
		else
			printf("=== ECRIRE UN MESSAGE ===\n\n");

		if (erreur)
		{
			printf("Une erreur est survenue lors de la saisie veuillez réessayer !\n");
			erreur = 0;
		}
		
		printf("Titre : ");		
		fgets(titre, 49, stdin);
		
		printf("Texte : ");
		fgets(texteMsg, 499, stdin);
		
		titre[strcspn(titre, "\r\n")] = 0;
		texteMsg[strcspn(texteMsg, "\r\n")] = 0;
		
		if (titre[0] != '\0' && texteMsg[0] != '\0')
		{			
			EXEC SQL SELECT MAX(idMessage) INTO :idMax FROM FORUM_MESSAGE;
			
			if (msgPere != -1)
				EXEC SQL INSERT INTO FORUM_MESSAGE VALUES (:idMax + 1, :titre, SYSDATE, :username, :texteMsg, :idGroupe, :MsgPere);
			else
				EXEC SQL INSERT INTO FORUM_MESSAGE VALUES (:idMax + 1, :titre, SYSDATE, :username, :texteMsg, :idGroupe, NULL);
			
			EXEC SQL COMMIT WORK;
				
			printf("Message créer avec succès !\n");
			Wait_For_Enter();
			return;
		}
		else
			erreur = 1;
		
	}
	
}

void afficherMessage(int idMessage, int idGroupe)
{
	EXEC SQL BEGIN DECLARE SECTION;

	char Titre[50];
	char DateMsg[30];
	char Auteur[30];
	char Texte[300];
	int MsgPere;
	int idMessageFils;
	
	short idest_Titre;
	short idest_IdMessageFils;
	short idest_MsgPere;
	short idest_DateMsg;
	short idest_Auteur;
	short idest_Texte;
	
EXEC SQL END DECLARE SECTION;
	
	char choix[10];
	int nbrMessagesFils = 0;
	int sizeTabIdMessagesFils = 10;
	int *tabIdMessagesFils = malloc(sizeof(int) * sizeTabIdMessagesFils);
	MsgPere = -1;
	while (1)
	{
		nbrMessagesFils = 0;
		#ifdef WINDOWS
		SetConsoleTitle("Ultra Forum Discutor - Lecture d'un message");
		#endif
		clearScreen();
		
		//printf("MESSAGE ID : %d / Page : %d\n", idMessage, page);
		
		printf("=== LECTURE D'UN MESSAGE ===\n");
		
		EXEC SQL SELECT Titre, Datemsg, Auteur, Texte, MsgPere INTO :Titre:idest_Titre, :DateMsg:idest_DateMsg, :Auteur:idest_Auteur, :Texte:idest_Texte, :MsgPere:idest_MsgPere FROM FORUM_MESSAGE WHERE idMessage = :idMessage;
		
		printf("Titre : %s\n", Titre);
		printf("Date : %s\n", DateMsg);
		printf("Auteur : %s\n", Auteur);
		printf("Texte : %s\n", Texte);
		//printf("MsgPere : %d\n", MsgPere);
		
		printf("--------------------------\n");
		printf("\nListe des messages fils : \n\n");
		//printf("%d", idest_Titre);
		
		EXEC SQL DECLARE messagesFils CURSOR FOR SELECT idMessage, Titre, MsgPere FROM FORUM_MESSAGE WHERE MsgPere = :idMessage;
		EXEC SQL OPEN messagesFils;	
		EXEC SQL FETCH messagesFils INTO :idMessageFils:idest_IdMessageFils, :Titre:idest_Titre, :MsgPere:idest_MsgPere;
		
		//printf("Nbr messages fils : %d / Tab : %d / Size tab %d\n", nbrMessagesFils, tabIdMessagesFils[nbrMessagesFils], sizeTabIdMessagesFils);
		while ((sqlca.sqlcode >= 0) && (sqlca.sqlcode != 1403)) //Tant que le curseur n'est pas vide !
		{
			if (idest_Titre != -1 || idest_IdMessageFils != -1 || idest_MsgPere != -1) //Si il ne s'agit pas d'une case vide
			{
				if (nbrMessagesFils >= sizeTabIdMessagesFils)
				{
					tabIdMessagesFils = realloc(tabIdMessagesFils, sizeof(int) * (sizeTabIdMessagesFils + 10));
					sizeTabIdMessagesFils += 10;
				}
					
				Titre[strcspn(Titre, "\r\n")] = 0; //On retire les sauts de ligne du message si il y en a
				printf("\t%d - %s\n", nbrMessagesFils, Titre); //On affiche le groupe	
				//printf("Nbr messages fils : %d / Tab : %d / Size tab %d\n / Id Message : %d", nbrMessagesFils, tabIdMessagesFils[nbrMessagesFils], sizeTabIdMessagesFils, idMessageFils);				
				tabIdMessagesFils[nbrMessagesFils] = idMessageFils;
				EXEC SQL FETCH messagesFils INTO :idMessageFils:idest_IdMessageFils, :Titre:idest_Titre, :MsgPere:idest_MsgPere;
				nbrMessagesFils += 1;
			}
		}
		
		EXEC SQL CLOSE messagesFils;
		
		//printf("Nbr messages fils : %d / Tab : %d / Size tab %d\n", nbrMessagesFils, tabIdMessagesFils[nbrMessagesFils], sizeTabIdMessagesFils);
		printf("\nActions :\n");
		printf("\t- Entrez le chiffre associé au message pour y accéder\n");
		printf("\t- R : Répondre au message\n");
		
		if(estModerateur(login.arr, idGroupe))
			printf("\t- S : Supprimer le message\n");
			
		printf("\t- M : Revenir à la liste des messages\n");
		
		printf("\nEntrez votre choix : ");
		scanf("%2s", choix);
		
		if (isNumber(choix))
		{
			int choixInt = atoi(choix);
			
			if (choixInt >= 0 && choixInt < nbrMessagesFils)
			{
				afficherMessage(tabIdMessagesFils[choixInt], idGroupe);
			}
		}
		else if (!strcmp(choix, "m") || !strcmp(choix, "M")) //Si l'on veut revenir à la liste des messages
		{
			free(tabIdMessagesFils);
			return;
		}
		else if (estModerateur(login.arr, idGroupe) && (!strcmp(choix, "s") || !strcmp(choix, "S"))) //Si l'on est moderateur et que l'on veut supprimer le message
		{
			EXEC SQL DELETE FROM Forum_Message WHERE IdMessage = :idMessage;
			EXEC SQL COMMIT WORK;
			printf("Le message a été supprimé avec succès !\n");
			Wait_For_Enter();
			free(tabIdMessagesFils);
			return;
		}
		else if (!strcmp(choix, "r") || !strcmp(choix, "R")) //Si l'on veut répondre au message
		{
			ecrireMessage(idGroupe, idMessage);
		}
		
		//viderBuffer();
		
	}

}

/*  FONCTIONS UTILITAIRES  */

int isNumber(char* str)
{
	int length = strlen(str);
	int i;
	
    for (i = 0 ; i < length; i++)
	{
        if (!isdigit(str[i]))
        {
            return 0;
        }
	}
	
	return 1;
}

EXEC SQL BEGIN DECLARE SECTION;
	char ModName[30];
	short idest_Mod = -1;
	int countMod = 0;
EXEC SQL END DECLARE SECTION;

int estModerateur(char *account, int idGroupe) //Retourne 0 si n'est pas moderateur / Retourne 2 si l'utilisateur est moderateur
{
	if (strlen(account) < 30)
		strcpy(ModName, account);
	else
		strcpy("", account);
	
	EXEC SQL SELECT Count("Mod") INTO :countMod:idest_Mod FROM FORUM_MODERATEUR Where "Mod" = :ModName And idGroupe = :idGroupe;
	
	if (!countMod)
		return 0;
	else
		return 1;

}

void clearScreen()
{
	#ifdef WINDOWS
	system("cls");
	#endif
	
	#ifdef LINUX
	system("clear");
	#endif
}

void viderBuffer()
{
	int c = 0;

	while (c != '\n' && c != EOF)
	{
		c = getchar(); //On prend les charactères restants dans le buffer
	}
}

void Wait_For_Enter()
{
	#ifdef LINUX
	printf("Appuyez sur Entrée pour continuer !");
	viderBuffer();
	getchar(); //On attend la touche entrée
	#endif
	
	#ifdef WINDOWS
	system("pause");
	#endif
}

#ifdef LINUX
char* strupr(char* s)
{
    char* tmp = s;

    for (;*tmp;++tmp) {
        *tmp = toupper((unsigned char) *tmp);
    }

    return s;
}
#endif